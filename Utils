import android.content.Context;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager.NameNotFoundException;
import android.database.Cursor;
import android.os.Build;
import android.os.ParcelFileDescriptor;
import android.text.TextUtils;
import android.util.Log;

import java.io.Closeable;
import java.io.InterruptedIOException;

public class Utils {
    private static final String TAG = "Utils";
    private static final String DEBUG_TAG = "GalleryDebug";

    private static final long POLY64REV = 0x95AC9329AC4BC9B5L;
    private static final long INITIALCRC = 0xFFFFFFFFFFFFFFFFL;

    private static long[] sCrcTable = new long[256];

    private static final boolean IS_DEBUG_BUILD =
            Build.TYPE.equals("eng") || Build.TYPE.equals("userdebug");

    private static final String MASK_STRING = "********************************";

    // Throws AssertionError if the input is false.
    public static void assertTrue(boolean cond) {
        if (!cond) {
            throw new AssertionError();
        }
    }

    // Throws AssertionError with the message. We had a method having the form
    //   assertTrue(boolean cond, String message, Object ... args);
    // However a call to that method will cause memory allocation even if the
    // condition is false (due to autoboxing generated by "Object ... args"),
    // so we don't use that anymore.
    public static void fail(String message, Object ... args) {
        throw new AssertionError(
                args.length == 0 ? message : String.format(message, args));
    }

    // Throws NullPointerException if the input is null.
    public static <T> T checkNotNull(T object) {
        if (object == null) throw new NullPointerException();
        return object;
    }

    // Returns true if two input Object are both null or equal
    // to each other.
    public static boolean equals(Object a, Object b) {
        return (a == b) || (a == null ? false : a.equals(b));
    }

    // Returns the next power of two.
    // Returns the input if it is already power of 2.
    // Throws IllegalArgumentException if the input is <= 0 or
    // the answer overflows.
    public static int nextPowerOf2(int n) {
        if (n <= 0 || n > (1 << 30)) throw new IllegalArgumentException("n is invalid: " + n);
        n -= 1;
        n |= n >> 16;
        n |= n >> 8;
        n |= n >> 4;
        n |= n >> 2;
        n |= n >> 1;
        return n + 1;
    }

    // Returns the previous power of two.
    // Returns the input if it is already power of 2.
    // Throws IllegalArgumentException if the input is <= 0
    public static int prevPowerOf2(int n) {
        if (n <= 0) throw new IllegalArgumentException();
        return Integer.highestOneBit(n);
    }

    // Returns the input value x clamped to the range [min, max].
    public static int clamp(int x, int min, int max) {
        if (x > max) return max;
        if (x < min) return min;
        return x;
    }

    // Returns the input value x clamped to the range [min, max].
    public static float clamp(float x, float min, float max) {
        if (x > max) return max;
        if (x < min) return min;
        return x;
    }

    // Returns the input value x clamped to the range [min, max].
    public static long clamp(long x, long min, long max) {
        if (x > max) return max;
        if (x < min) return min;
        return x;
    }

    public static boolean isOpaque(int color) {
        return color >>> 24 == 0xFF;
    }

    public static void swap(int[] array, int i, int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }

    /**
     * A function thats returns a 64-bit crc for string
     *
     * @param in input string
     * @return a 64-bit crc value
     */
    public static final long crc64Long(String in) {
        if (in == null || in.length() == 0) {
            return 0;
        }
        return crc64Long(getBytes(in));
    }

    static {
        // http://bioinf.cs.ucl.ac.uk/downloads/crc64/crc64.c
        long part;
        for (int i = 0; i < 256; i++) {
            part = i;
            for (int j = 0; j < 8; j++) {
                long x = ((int) part & 1) != 0 ? POLY64REV : 0;
                part = (part >> 1) ^ x;
            }
            sCrcTable[i] = part;
        }
    }

    public static final long crc64Long(byte[] buffer) {
        long crc = INITIALCRC;
        for (int k = 0, n = buffer.length; k < n; ++k) {
            crc = sCrcTable[(((int) crc) ^ buffer[k]) & 0xff] ^ (crc >> 8);
        }
        return crc;
    }

    public static byte[] getBytes(String in) {
        byte[] result = new byte[in.length() * 2];
        int output = 0;
        for (char ch : in.toCharArray()) {
            result[output++] = (byte) (ch & 0xFF);
            result[output++] = (byte) (ch >> 8);
        }
        return result;
    }

    public static void closeSilently(Closeable c) {
        if (c == null) return;
        try {
            c.close();
        } catch (Throwable t) {
            Log.w(TAG, "close fail", t);
        }
    }

    public static int compare(long a, long b) {
        return a < b ? -1 : a == b ? 0 : 1;
    }

    public static int ceilLog2(float value) {
        int i;
        for (i = 0; i < 31; i++) {
            if ((1 << i) >= value) break;
        }
        return i;
    }

    public static int floorLog2(float value) {
        int i;
        for (i = 0; i < 31; i++) {
            if ((1 << i) > value) break;
        }
        return i - 1;
    }

    public static void closeSilently(ParcelFileDescriptor fd) {
        try {
            if (fd != null) fd.close();
        } catch (Throwable t) {
            Log.w(TAG, "fail to close", t);
        }
    }

    public static void closeSilently(Cursor cursor) {
        try {
            if (cursor != null) cursor.close();
        } catch (Throwable t) {
            Log.w(TAG, "fail to close", t);
        }
    }

    public static float interpolateAngle(
            float source, float target, float progress) {
        // interpolate the angle from source to target
        // We make the difference in the range of [-179, 180], this is the
        // shortest path to change source to target.
        float diff = target - source;
        if (diff < 0) diff += 360f;
        if (diff > 180) diff -= 360f;

        float result = source + diff * progress;
        return result < 0 ? result + 360f : result;
    }

    public static float interpolateScale(
            float source, float target, float progress) {
        return source + progress * (target - source);
    }

    public static String ensureNotNull(String value) {
        return value == null ? "" : value;
    }

    public static float parseFloatSafely(String content, float defaultValue) {
        if (content == null) return defaultValue;
        try {
            return Float.parseFloat(content);
        } catch (NumberFormatException e) {
            return defaultValue;
        }
    }

    public static int parseIntSafely(String content, int defaultValue) {
        if (content == null) return defaultValue;
        try {
            return Integer.parseInt(content);
        } catch (NumberFormatException e) {
            return defaultValue;
        }
    }

    public static boolean isNullOrEmpty(String exifMake) {
        return TextUtils.isEmpty(exifMake);
    }

    public static void waitWithoutInterrupt(Object object) {
        try {
            object.wait();
        } catch (InterruptedException e) {
            Log.w(TAG, "unexpected interrupt: " + object);
        }
    }

    public static boolean handleInterrruptedException(Throwable e) {
        // A helper to deal with the interrupt exception
        // If an interrupt detected, we will setup the bit again.
        if (e instanceof InterruptedIOException
                || e instanceof InterruptedException) {
            Thread.currentThread().interrupt();
            return true;
        }
        return false;
    }

    /**
     * @return String with special XML characters escaped.
     */
    public static String escapeXml(String s) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0, len = s.length(); i < len; ++i) {
            char c = s.charAt(i);
            switch (c) {
                case '<':  sb.append("&lt;"); break;
                case '>':  sb.append("&gt;"); break;
                case '\"': sb.append("&quot;"); break;
                case '\'': sb.append("&#039;"); break;
                case '&':  sb.append("&amp;"); break;
                default: sb.append(c);
            }
        }
        return sb.toString();
    }

    public static String getUserAgent(Context context) {
        PackageInfo packageInfo;
        try {
            packageInfo = context.getPackageManager().getPackageInfo(context.getPackageName(), 0);
        } catch (NameNotFoundException e) {
            throw new IllegalStateException("getPackageInfo failed");
        }
        return String.format("%s/%s; %s/%s/%s/%s; %s/%s/%s",
                packageInfo.packageName,
                packageInfo.versionName,
                Build.BRAND,
                Build.DEVICE,
                Build.MODEL,
                Build.ID,
                Build.VERSION.SDK_INT,
                Build.VERSION.RELEASE,
                Build.VERSION.INCREMENTAL);
    }

    public static String[] copyOf(String[] source, int newSize) {
        String[] result = new String[newSize];
        newSize = Math.min(source.length, newSize);
        System.arraycopy(source, 0, result, 0, newSize);
        return result;
    }

    // Mask information for debugging only. It returns <code>info.toString()</code> directly
    // for debugging build (i.e., 'eng' and 'userdebug') and returns a mask ("****")
    // in release build to protect the information (e.g. for privacy issue).
    public static String maskDebugInfo(Object info) {
        if (info == null) return null;
        String s = info.toString();
        int length = Math.min(s.length(), MASK_STRING.length());
        return IS_DEBUG_BUILD ? s : MASK_STRING.substring(0, length);
    }

    // This method should be ONLY used for debugging.
    public static void debug(String message, Object ... args) {
        Log.v(DEBUG_TAG, String.format(message, args));
    }
    
    /**
     * 根据图片绝对路径从数据库中查询记录
     * @param mContext
     * @param filePath
     * @return  返回查询到的游标
     */
    public static Cursor queryByPath(Context mContext, String filePath)
    {
        Uri baseUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;//图片类型的Uri
        Uri query = baseUri.buildUpon().appendQueryParameter("limit", "1").build();
        String[] projection =
        {
                ImageColumns._ID, // 0
                ImageColumns.TITLE, // 1
                ImageColumns.MIME_TYPE, // 2
                ImageColumns.LATITUDE, // 3
                ImageColumns.LONGITUDE, // 4
                ImageColumns.DATE_TAKEN, // 5
                ImageColumns.DATE_ADDED, // 6
                ImageColumns.DATE_MODIFIED, // 7
                ImageColumns.DATA, // 8
                ImageColumns.ORIENTATION, // 9
                ImageColumns.BUCKET_ID, // 10
                ImageColumns.SIZE
                // 11
        };
        String selection = ImageColumns.DATA + "=" + filePath;
        String order = ImageColumns.DATE_TAKEN + " DESC," + ImageColumns._ID + " DESC";
        Cursor cursor = null;
        try
        {
            cursor = mContext.getContentResolver().query(query, projection, selection, null, order);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
        return cursor;
    }

    /**
     * 根据图片绝对路径获取Uri
     * @param mContext
     * @param filePath
     * @return  返回Uri
     */
    public static Uri getUriByPath(Context mContext, String filePath)
    {
        Uri baseUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;//图片类型的Uri
        Uri query = baseUri.buildUpon().appendQueryParameter("limit", "1").build();
        String[] projection =
        {
                ImageColumns._ID, // 0
        };
        String selection = ImageColumns.DATA + "=" + filePath;
        String order = ImageColumns.DATE_TAKEN + " DESC," + ImageColumns._ID + " DESC";
        Cursor cursor = null;
        try
        {
            cursor = mContext.getContentResolver().query(query, projection, selection, null, order);
            if (cursor != null && cursor.moveToFirst())
            {
                long id = cursor.getLong(0);
                return ContentUris.withAppendedId(baseUri, id);
            }
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * 根据图片绝对路径向数据库中插入图片记录
     * @param mContext
     * @param filePath
     * @return  返回插入的Uri
     */
    public static Uri insertImageByPath(Context mContext, String filePath, int width, int height)
    {
        Uri uri = null;
        try
        {
            // Insert into MediaStore.
            if (filePath == null)
                return null;
            String title = FileUtil.getFileNameByPath(filePath);
            String titleWithSuffix = FileUtil.getFileNameIncludeSuffixByPath(filePath);
            BitmapFactory.Options opts = new BitmapFactory.Options();
            opts.inJustDecodeBounds = true; //确保图片不加载到内存 
            BitmapFactory.decodeFile(filePath, opts);
            ExifInterface exif = new ExifInterface(filePath);
            int size = 0;
            int orientation = 0;
            try
            {
                size = Integer.valueOf(exif.TAG_IMAGE_LENGTH);
                orientation = Integer.valueOf(exif.TAG_ORIENTATION);
            }
            catch (Exception e)
            {
                size = 1024 * 100;
            }
            if (size == 0)
            {
                size = 1024 * 100;
            }
            long date = System.currentTimeMillis();
            ContentValues values = new ContentValues();
            values.put(ImageColumns.TITLE, title);
            values.put(ImageColumns.DISPLAY_NAME, titleWithSuffix);
            values.put(ImageColumns.DATE_TAKEN, date);
            values.put(ImageColumns.DATE_MODIFIED, date / 1000);
            values.put(ImageColumns.MIME_TYPE, opts.outMimeType);
            values.put(ImageColumns.DATA, filePath);
            values.put(ImageColumns.SIZE, size);
            // Clockwise rotation in degrees. 0, 90, 180, or 270.
            values.put(ImageColumns.ORIENTATION, orientation);
            values.put(ImageColumns.WIDTH, width);
            values.put(ImageColumns.HEIGHT, height);
            uri = mContext.getContentResolver().insert(Images.Media.EXTERNAL_CONTENT_URI, values);
        }
        catch (Throwable th)
        {
            Log.e(TAG, "Failed to write MediaStore" + th);
        }
        return uri;
    }

    /**
     * 根据图片绝对路径向数据库中插入图片记录
     * @param mContext
     * @param filePath
     * @return  返回插入的Uri
     */
    public static Uri insertImageByPath(Context mContext, String filePath)
    {
        Uri uri = null;
        try
        {
            // Insert into MediaStore.
            if (filePath == null)
                return null;
            String title = FileUtil.getFileNameByPath(filePath);
            String titleWithSuffix = FileUtil.getFileNameIncludeSuffixByPath(filePath);
            BitmapFactory.Options opts = new BitmapFactory.Options();
            opts.inJustDecodeBounds = true; //确保图片不加载到内存 
            BitmapFactory.decodeFile(filePath, opts);
            ExifInterface exif = new ExifInterface(filePath);
            int size = 0;
            int orientation = 0;
            try
            {
                size = Integer.valueOf(exif.TAG_IMAGE_LENGTH);
                orientation = Integer.valueOf(exif.TAG_ORIENTATION);
            }
            catch (Exception e)
            {
                size = 1024 * 100;
            }
            if (size == 0)
            {
                size = 1024 * 100;
            }
            long date = System.currentTimeMillis();
            ContentValues values = new ContentValues();
            values.put(ImageColumns.TITLE, title);
            values.put(ImageColumns.DISPLAY_NAME, titleWithSuffix);
            values.put(ImageColumns.DATE_TAKEN, date);
            values.put(ImageColumns.DATE_MODIFIED, date / 1000);
            values.put(ImageColumns.MIME_TYPE, opts.outMimeType);
            values.put(ImageColumns.DATA, filePath);
            values.put(ImageColumns.SIZE, size);
            // Clockwise rotation in degrees. 0, 90, 180, or 270.
            values.put(ImageColumns.ORIENTATION, orientation);
            values.put(ImageColumns.WIDTH, opts.outWidth);
            values.put(ImageColumns.HEIGHT, opts.outHeight);
            uri = mContext.getContentResolver().insert(Images.Media.EXTERNAL_CONTENT_URI, values);
        }
        catch (Throwable th)
        {
            Log.e(TAG, "Failed to write MediaStore" + th);
        }
        return uri;
    }

    /**
     * 根据图片绝对路径从系统数据库的images表中删除记录
     * 
     * @param mContext
     * @param filePath
     * @return 返回删除的行数
     */
    public static int deleteImageByPath(Context mContext, String filePath)
    {
        try
        {
            Uri baseUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;// 图片类型的Uri
            // content://meida/images/media
            String where = ImageColumns.DATA + "=?";
            //Log.e(TAG, "deleteImageByPath: uri=" + baseUri + ",file:" + filePath);
            return mContext.getContentResolver().delete(baseUri, where, new String[]
            {
                    filePath
            });
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
        return 0;
    }

    /**
     * 根据图片绝对路径从系统数据库的images表中更新记录
     * 
     * @param mContext
     * @param filePath
     * @param newFilePath
     * @return 返回更新的行数
     */
    public static int updateImageByPath(Context mContext, String filePath, String newFilePath)
    {
        try
        {
            Uri baseUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;// 图片类型的Uri
            String where = ImageColumns.DATA + "=?" + filePath;
            ContentValues values = new ContentValues(1);
            values.put(ImageColumns.DATA, newFilePath);
            return mContext.getContentResolver().update(baseUri, values, where, new String[]
            {
                    filePath
            });// 在数据库中更新图片路径字段
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
        return 0;
    }
    
    public static void leftInRightOut(final View leftView, final View rightView, long duration)
    {
        TranslateAnimation animationRight = new TranslateAnimation(
                0, rightView.getRight(), 0, 0);
        animationRight.setDuration(duration);
        Animation animationRight2 = new AlphaAnimation(1F, 0F);
        animationRight2.setDuration(duration);
        AnimationSet animationRight3 = new AnimationSet(true);
        animationRight3.addAnimation(animationRight);
        animationRight3.addAnimation(animationRight2);
        animationRight3.setAnimationListener(new AnimationListener()
        {

            @Override
            public void onAnimationStart(Animation animation)
            {
                // TODO Auto-generated method stub

            }

            @Override
            public void onAnimationRepeat(Animation animation)
            {
                // TODO Auto-generated method stub

            }

            @Override
            public void onAnimationEnd(Animation animation)
            {
                rightView.setVisibility(View.GONE);
            }
        });
        rightView.setEnabled(false);
        rightView.startAnimation(animationRight3);

        TranslateAnimation animationLeft = new TranslateAnimation(
                -leftView.getRight() == 0 ? -rightView.getRight() : -leftView.getRight(), 0, 0, 0);
        animationLeft.setDuration(duration);
        Animation animationLeft2 = new AlphaAnimation(0F, 1F);
        animationLeft2.setDuration(duration);
        AnimationSet animationLeft3 = new AnimationSet(true);
        animationLeft3.addAnimation(animationLeft);
        animationLeft3.addAnimation(animationLeft2);
        animationLeft3.setAnimationListener(new AnimationListener()
        {

            @Override
            public void onAnimationStart(Animation animation)
            {
                // TODO Auto-generated method stub

            }

            @Override
            public void onAnimationRepeat(Animation animation)
            {
                // TODO Auto-generated method stub

            }

            @Override
            public void onAnimationEnd(Animation animation)
            {
                leftView.setVisibility(View.VISIBLE);
            }
        });
        leftView.setEnabled(true);
        leftView.startAnimation(animationLeft3);

    }


    public static StateListDrawable newSelector(Context context, int idNormal, int idPressed,
            int idFocused,
            int idUnable)
    {
        StateListDrawable bg = new StateListDrawable();
        Drawable normal = idNormal == -1 ? null : context.getResources().getDrawable(idNormal);
        Drawable pressed = idPressed == -1 ? null : context.getResources().getDrawable(idPressed);
        Drawable focused = idFocused == -1 ? null : context.getResources().getDrawable(idFocused);
        Drawable unable = idUnable == -1 ? null : context.getResources().getDrawable(idUnable);
        // View.PRESSED_ENABLED_STATE_SET
        bg.addState(new int[]
        {
                android.R.attr.state_pressed, android.R.attr.state_enabled
        }, pressed);
        // View.ENABLED_FOCUSED_STATE_SET
        bg.addState(new int[]
        {
                android.R.attr.state_enabled, android.R.attr.state_focused
        }, focused);
        // View.ENABLED_STATE_SET
        bg.addState(new int[]
        {
                android.R.attr.state_enabled
        }, normal);
        // View.FOCUSED_STATE_SET
        bg.addState(new int[]
        {
                android.R.attr.state_focused
        }, focused);
        // View.WINDOW_FOCUSED_STATE_SET
        bg.addState(new int[]
        {
                android.R.attr.state_window_focused
        }, unable);
        // View.EMPTY_STATE_SET
        bg.addState(new int[] {}, normal);
        return bg;
    }

    public static StateListDrawable newSelector(Context context, Bitmap idNormal, Bitmap idPressed,
            Bitmap idFocused,
            Bitmap idUnable)
    {
        StateListDrawable bg = new StateListDrawable();
        Drawable normal = idNormal == null ? null : new BitmapDrawable(context.getResources(),
                idNormal);
        Drawable pressed = idPressed == null ? null : new BitmapDrawable(context.getResources(),
                idPressed);
        Drawable focused = idFocused == null ? null : new BitmapDrawable(context.getResources(),
                idFocused);
        Drawable unable = idUnable == null ? null : new BitmapDrawable(context.getResources(),
                idUnable);
        // View.PRESSED_ENABLED_STATE_SET
        bg.addState(new int[]
        {
                android.R.attr.state_pressed, android.R.attr.state_enabled
        }, pressed);
        // View.ENABLED_FOCUSED_STATE_SET
        bg.addState(new int[]
        {
                android.R.attr.state_enabled, android.R.attr.state_focused
        }, focused);
        // View.ENABLED_STATE_SET
        bg.addState(new int[]
        {
                android.R.attr.state_enabled
        }, normal);
        // View.FOCUSED_STATE_SET
        bg.addState(new int[]
        {
                android.R.attr.state_focused
        }, focused);
        // View.WINDOW_FOCUSED_STATE_SET
        bg.addState(new int[]
        {
                android.R.attr.state_window_focused
        }, unable);
        // View.EMPTY_STATE_SET
        bg.addState(new int[] {}, normal);
        return bg;
    }
}
